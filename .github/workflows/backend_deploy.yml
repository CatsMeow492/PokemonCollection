name: Deploy to Elastic Beanstalk

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Go
        uses: actions/setup-go@v3
        with:
          go-version: '1.23'

      - name: Update dependencies
        run: |
          cd backend
          go get -u ./...
          go mod tidy

      - name: Build application
        run: |
          cd backend
          go build -o CardVault
          cd ..
          zip -r application.zip backend/CardVault .ebextensions/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Upload to S3
        run: |
          aws s3 cp application.zip s3://${{ secrets.AWS_EB_APPLICATION_NAME }}-deployment-bucket/application-${{ github.run_number }}.zip

      - name: Get latest Go solution stack
        run: |
          SOLUTION_STACK=$(aws elasticbeanstalk list-available-solution-stacks --output json | jq -r '.SolutionStacks[] | select(contains("running Go 1"))' | head -n 1)
          if [ -z "$SOLUTION_STACK" ]; then
            echo "Error: No suitable solution stack found for Go 1."
            exit 1
          fi
          echo "SOLUTION_STACK=$SOLUTION_STACK" >> $GITHUB_ENV
          echo "Selected solution stack: $SOLUTION_STACK"

      - name: Deploy to Elastic Beanstalk
        run: |
          # Create a unique version label using the GitHub run number, short SHA of the commit, and a timestamp
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          VERSION_LABEL="${{ github.run_number }}-${{ github.sha }}-$TIMESTAMP"
          echo "Using version label: $VERSION_LABEL"

          # Check for terminated environments and terminate them
          TERMINATED_ENV=$(aws elasticbeanstalk describe-environments --environment-names "${{ secrets.AWS_EB_ENVIRONMENT_NAME }}" --include-deleted --query 'Environments[?Status==`Terminated`].EnvironmentName' --output text)
          if [ "$TERMINATED_ENV" == "${{ secrets.AWS_EB_ENVIRONMENT_NAME }}" ]; then
            echo "Terminating environment: $TERMINATED_ENV"
            aws elasticbeanstalk terminate-environment --environment-name "$TERMINATED_ENV"
          fi

          # Check if the environment exists
          if ! aws elasticbeanstalk describe-environments --environment-names "${{ secrets.AWS_EB_ENVIRONMENT_NAME }}" --no-include-deleted | grep -q "${{ secrets.AWS_EB_ENVIRONMENT_NAME }}"; then
            echo "Environment does not exist. Creating new environment..."
            echo "Using solution stack: ${{ env.SOLUTION_STACK }}"
            # Create a new environment
            aws elasticbeanstalk create-environment \
              --application-name "${{ secrets.AWS_EB_APPLICATION_NAME }}" \
              --environment-name "${{ secrets.AWS_EB_ENVIRONMENT_NAME }}" \
              --solution-stack-name "${{ env.SOLUTION_STACK }}" \
              --option-settings file://eb-options.json \
              --version-label "$VERSION_LABEL"
          else
            echo "Environment exists. Updating environment..."
            # Update existing environment
            aws elasticbeanstalk update-environment \
              --application-name "${{ secrets.AWS_EB_APPLICATION_NAME }}" \
              --environment-name "${{ secrets.AWS_EB_ENVIRONMENT_NAME }}" \
              --version-label "$VERSION_LABEL"
          fi
